{"slots":{"0":{"name":"slot1","type":{"events":[],"methods":[]}},"1":{"name":"slot2","type":{"events":[],"methods":[]}},"2":{"name":"slot3","type":{"events":[],"methods":[]}},"3":{"name":"slot4","type":{"events":[],"methods":[]}},"4":{"name":"slot5","type":{"events":[],"methods":[]}},"5":{"name":"slot6","type":{"events":[],"methods":[]}},"6":{"name":"slot7","type":{"events":[],"methods":[]}},"7":{"name":"slot8","type":{"events":[],"methods":[]}},"8":{"name":"slot9","type":{"events":[],"methods":[]}},"9":{"name":"slot10","type":{"events":[],"methods":[]}},"-1":{"name":"unit","type":{"events":[],"methods":[]}},"-3":{"name":"player","type":{"events":[],"methods":[]}},"-2":{"name":"construct","type":{"events":[],"methods":[]}},"-4":{"name":"system","type":{"events":[],"methods":[]}},"-5":{"name":"library","type":{"events":[],"methods":[]}}},"handlers":[{"code":"-- Augmented Reality damage repport and holographic display by Jeronimo 2024\n-- credit to TheGreatSardini for health points Ui design\n\nshowFullHp = false --export\nscale = 0.035 --export: scale of the dammage repport\nscaleToggle = true\nlayersX = 2 --export: meters in between each slices\nlayersY = 2 --export: meters in between each slices\nlayersZ = 2 --export: meters in between each slices\noffsetZ = 0.25 --export\nfillColor = \"MidnightBlue\" --export\nfillOpacity = 0.05 --export\nstrokeWidth = 2 --export\nstrokeColor = \"cyan\" --export\nstrokeOpacity = 0.75 --export\npointsColor = \"cyan\" --export\nsliceX = true --export\nsliceY = true --export\nsliceZ = false --export\nrotationSpeed = 2 --export\nrotationAxis = {0,0,1} --export\nrot = 0\n\ncustomPointsCloud = {}\n\nsystem.print(\"---------------------------------------------------------------\")\nsystem.print(\"Welcome to use Jeronimo's Advanced Scripted Technologies!\")\nsystem.print(\"Augmented Reality damage repport and holographic display\")\n\nlocal function findConnectedSlots()\n    local slot = {}\n    for slotName in pairs(unit) do\n        slot = unit[slotName]\n        if\n            type(slot) == \"table\" and unit[slotName].getClass ~= nil and slotName ~= \"system\" and slotName ~= \"library\" and\n                slotName ~= \"unit\" and\n                slotName ~= \"export\"\n         then\n            --system.print(slot.getClass())\n            if string.sub(slot.getClass(), 1, 8) == \"CoreUnit\" then\n                core = slot\n                system.print(\"Core found\")\n            end\n        end\n    end\n    if core ~= nil and slot2 ~= nil then\n        system.print(\"Links initialisation complete\")\n    else\n        system.print(\"Links initialisation failed:\")\n        system.print(\"Please link programming board to the Core to first slot, then any element to second slot\")\n        unit.exit()\n    end\nend\nfindConnectedSlots()\n\nelementsIDs = core.getElementIdList()\nelementsPos = {}\nelementsDupePos = {}\nfor i, id in ipairs(elementsIDs) do\n    elementsPos[i] = core.getElementPositionById(id)\n    elementsDupePos[i] = core.getElementPositionById(id)\nend\n\nsystem.print(\"Number of elements: \"..#elementsPos)\n\n\n--unit.hideWidget()\ninit = false\ninitCount = 0\nlayeredPolylinePoints = {}\nunit.setTimer(\"init\",0.5)\n  \nsystem.showScreen(1)\n\nsystem.print(\"Press ALT to change scale!\")\nsystem.print(\"Press SHIFT to toggle full health display!\")\nsystem.print(\"Initialisation succesfull, check lua external parameters for more options!\")\nsystem.print(\"---------------------------------------------------------------\")\n","filter":{"args":[],"signature":"onStart()","slotKey":"-1"},"key":"0"},{"code":"-- Calculate the cross product of vectors (p1-p0) and (p2-p0)\nlocal function crossProduct(p0, p1, p2, x, y)\n    return (p1[x] - p0[x]) * (p2[y] - p0[y]) - (p1[y] - p0[y]) * (p2[x] - p0[x])\nend\n\n-- Check if point p2 is to the left of the line formed by p0 and p1\nlocal function isLeftTurn(p0, p1, p2, x, y)\n    return crossProduct(p0, p1, p2, x, y) > 0\nend\n\n-- Compute the convex hull of a set of points\nlocal function convexHull(points, x, y)\n    local n = #points\n    if n <= 2 then\n        return points\n    end\n\n    -- Sort points lexicographically (by [1], then [2])\n    table.sort(\n        points,\n        function(a, b)\n            if a[x] == b[x] then\n                return a[y] < b[y]\n            else\n                return a[x] < b[x]\n            end\n        end\n    )\n\n    local upperHull = {}\n    for i = 1, n do\n        while #upperHull >= 2 and not isLeftTurn(upperHull[#upperHull - 1], upperHull[#upperHull], points[i], x, y) do\n            table.remove(upperHull)\n        end\n        table.insert(upperHull, points[i])\n    end\n\n    local lowerHull = {}\n    for i = n, 1, -1 do\n        while #lowerHull >= 2 and not isLeftTurn(lowerHull[#lowerHull - 1], lowerHull[#lowerHull], points[i], x, y) do\n            table.remove(lowerHull)\n        end\n        table.insert(lowerHull, points[i])\n    end\n\n    -- Combine upper and lower hulls\n    table.remove(lowerHull) -- Remove duplicate point\n    for i = 1, #lowerHull do\n        table.insert(upperHull, lowerHull[i])\n    end\n\n    return upperHull\nend\n\nfunction sliceConstruct(x, y, z, lDiv)\n    local bBox = construct.getBoundingBoxSize()\n    local bBoxLen = bBox[z] -- 50\n    --system.print(\"BBox len: \"..bBoxLen)\n    local layersN = math.floor(bBoxLen / lDiv)\n    --system.print(layersN)\n    local layerDist = bBoxLen / layersN -- 5\n    --system.print(\"Layer dist: \"..layerDist)\n\n    local elementsPosLayered = {}\n    local elementsPointsCloud = #customPointsCloud and elementsDupePos or customPointsCloud\n    for l = 0, layersN, 1 do\n        --system.print(\"layer: \"..l)\n        elementsPosLayered[l+1] = {}\n        local ind = 0\n        local currentLayer = l * layerDist - bBoxLen / 2\n        --system.print(\"Current layer: \"..currentLayer)\n        local nextLayer = (l + 1) * layerDist - bBoxLen / 2\n        \n        for i, pos in ipairs(elementsPointsCloud) do\n            local px, py, pz = pos[1], pos[2], pos[3]\n            if z == 1 then\n                if currentLayer - px < nextLayer - px and currentLayer - px < layerDist and\n                        currentLayer - px > -layerDist\n                 then\n                    ind = ind + 1\n                    elementsPosLayered[l+1][ind] = {currentLayer, py, pz}\n                end\n            elseif z == 2 then\n                if currentLayer - py < nextLayer - py and currentLayer - py < layerDist and\n                        currentLayer - py > -layerDist\n                 then\n                    ind = ind + 1\n                    elementsPosLayered[l+1][ind] = {px, currentLayer, pz}\n                end\n            elseif z == 3 then\n                if currentLayer - pz < nextLayer - pz and currentLayer - pz < layerDist and\n                        currentLayer - pz > -layerDist\n                 then\n                    ind = ind + 1\n                    elementsPosLayered[l+1][ind] = {px, py, currentLayer}\n                    --system.print(px..\" / \"..py..\" / \"..currentLayer)\n                end\n            end\n        end\n        --system.print(#elementsPosLayered[l+1][ind])\n    end\n    local layersPolylinePoints = {}\n    for i, pointCloud in ipairs(elementsPosLayered) do\n        layersPolylinePoints[i] = convexHull(pointCloud, x, y, z)\n    end\n    return layersPolylinePoints\nend\n\n\n\ninitCount = initCount + 1\nif initCount == 1 then\n    layeredPolylinePoints[1] = sliceConstruct(2,3,1,layersX)\n    --system.print(#layersPolylinePointsX)\nelseif initCount == 2 then\n    layeredPolylinePoints[2] = sliceConstruct(1,3,2,layersY)\n    --system.print(#layersPolylinePointsY)\nelseif initCount == 3 then\n    layeredPolylinePoints[3] = sliceConstruct(1,2,3,layersZ)\n    --system.print(#layersPolylinePointsZ)\nelseif initCount == 4 then\n    init = true\n    unit.setTimer(\"vecRot\",0.1)\n    unit.stopTimer(\"init\")\nend\n","filter":{"args":[{"value":"init"}],"signature":"onTimer(tag)","slotKey":"-1"},"key":"1"},{"code":"if init and rotationSpeed ~= 0 and scaleToggle == true then\n    local sqrt, rad, cos, sin = math.sqrt, math.rad, math.cos, math.sin\n    \n    local axisPos = slot2.getPosition()\n    local axisPosx, axisPosy, axisPosz = axisPos[1], axisPos[2], axisPos[3]\n\n    local function normalizeVec(x,y,z) -- normalize unpacked vector\n        local l = sqrt(x*x + y*y + z*z)\n        return x/l, y/l, z/l\n    end\n\n    local function dotVec(x1,y1,z1,x2,y2,z2) -- dot product of unpacked vectors\n        return x1*x2 + y1*y2 + z1*z2\n    end\n\n    local function rotateVec(vx, vy, vz, phi, ax, ay, az) --rotation of unpacked vec : vector to rotate / rotation angle in rad / axis vector\n        local l = sqrt(ax*ax + ay*ay + az*az)\n        local ux, uy, uz = ax/l, ay/l, az/l\n        local c, s = cos(phi), sin(phi)\n        local m1x, m1y, m1z = (c + ux * ux * (1-c)), (ux * uy * (1-c) - uz * s), (ux * uz * (1-c) + uy * s)\n        local m2x, m2y, m2z = (uy * ux * (1-c) + uz * s), (c + uy * uy * (1-c)), (uy * uz * (1-c) - ux * s)\n        local m3x, m3y, m3z = (uz * ux * (1-c) - uy * s), (uz * uy * (1-c) + ux * s), (c + uz * uz * (1-c))\n        return m1x*vx+m1y*vy+m1z*vz, m2x*vx+m2y*vy+m2z*vz, m3x*vx+m3y*vy+m3z*vz\n    end\n\n    rot = rot < 360 and rot + rotationSpeed*0.005 or 0 -- rotation animation\n\n    local rx, ry, rz = 0, 0, 0\n    local rotx, roty, rotz = rotationAxis[1], rotationAxis[2], rotationAxis[3]\n    for i, pos in ipairs(elementsDupePos) do -- loop through inputText to adjust each letter rotation\n        local nx, ny, nz = pos[1], pos[2], pos[3]\n        rx, ry, rz = rotateVec(nx, ny, nz, \n            rad(rot), \n            rotx, roty, rotz)\n        elementsDupePos[i] = {rx, ry, rz}\n    end\n    for i, axis in ipairs(layeredPolylinePoints) do\n        for i2, layer in ipairs(axis) do\n            for i3, pos in ipairs(layer) do\n                local nx, ny, nz = pos[1], pos[2], pos[3]\n                rx, ry, rz = rotateVec(nx, ny, nz, \n                    rad(rot), \n                    rotx, roty, rotz)\n                layeredPolylinePoints[i][i2][i3] = {rx, ry, rz}\n            end\n        end\n    end\nelse\n\nend","filter":{"args":[{"value":"vecRot"}],"signature":"onTimer(tag)","slotKey":"-1"},"key":"2"},{"code":"if init then\n    local sqrt, tan, rad, format, concat, cos, sin, pi = math.sqrt, math.tan, math.rad, string.format, table.concat, math.cos, math.sin, math.pi\n\n    local function round(num, numDecimalPlaces) -- http://lua-users.org/wiki/SimpleRound\n        local mult = 10^(numDecimalPlaces or 0)\n        return math.floor(num * mult + 0.5) / mult\n    end            \n    local function hexToRGB(hex)\n        hex = hex:gsub(\"#\",\"\")\n        return tonumber(\"0x\"..hex:sub(1,2)), tonumber(\"0x\"..hex:sub(3,4)), tonumber(\"0x\"..hex:sub(5,6))\n    end\n    local function RGBToHex(r,g,b)\n        r,g,b = round(r),round(g),round(b)\n        return string.format(\"#%02x%02x%02x\",r,g,b)\n    end\n    local function lerp(a,b,t)\n        return a + (b - a) * t\n    end\n    local function colorGradient(a,b,t) --Returns gradiant T of a and b hex color\n        local ar, ag, ab = hexToRGB(a)\n        local br, bg, bb = hexToRGB(b)\n        return RGBToHex(lerp(ar,br,t), lerp(ag,bg,t), lerp(ab,bb,t))\n    end\n\n    local MDX = system.getMouseDeltaX()*1.5\n    local MDY = system.getMouseDeltaY()*1.5\n    local pV = player.getVelocity()\n    local pWP = player.getWorldPosition()\n\n    local sw = system.getScreenWidth()\n    local sh = system.getScreenHeight()\n    local vFov = system.getCameraVerticalFov()\n    local hFov = system.getCameraHorizontalFov()\n    local near = 0.1\n    local far = 100000000.0\n    local aspectRatio = sh/sw\n    local tanFov = 1.0/tan(rad(vFov)*0.5)\n    local field = -far/(far-near)\n    local af = aspectRatio*tanFov\n    local nq = near*field\n    local camPv3 = vec3(system.getCameraPos())\n    local camWP = system.getCameraWorldPos()\n    local camWPv3 = vec3(camWP)\n    local camWPx, camWPy, camWPz = camWP[1], camWP[2], camWP[3]\n    local camWF = system.getCameraWorldForward()\n    local camWFv3 = vec3(camWF)\n    local camWFx, camWFy, camWFz = camWF[1], camWF[2], camWF[3]\n    local camWR = system.getCameraWorldRight()\n    local camWRx, camWRy, camWRz = camWR[1], camWR[2], camWR[3]\n    local camWU = system.getCameraWorldUp()\n    local camWUx, camWUy, camWUz = camWU[1], camWU[2], camWU[3]\n\n    local cWP = construct.getWorldPosition()\n    local cWPx, cWPy, cWPz = cWP[1], cWP[2], cWP[3]\n    local cWOU = construct.getWorldOrientationUp()\n    local cWOUx, cWOUy, cWOUz = cWOU[1], cWOU[2], cWOU[3]\n    local cWOF = construct.getWorldOrientationForward()\n    local cWOFx, cWOFy, cWOFz = cWOF[1], cWOF[2], cWOF[3]\n    local cWOR = construct.getWorldOrientationRight()\n    local cWORx, cWORy, cWORz = cWOR[1], cWOR[2], cWOR[3]\n    local mPP = player.getPosition()\n    local mPPx, mPPy = mPP[1], mPP[2]\n\n    local adjPos = slot2.getPosition()\n    local adjPosx, adjPosy, adjPosz = adjPos[1], adjPos[2], adjPos[3]+offsetZ\n\n    local posX, posY, posZ = 0, 0, 0\n    local vx, vy, vz = 0, 0, 0\n    local sx, sy, sz = 0, 0, 0\n    local sPX, sPY = 0\n    local dist = 0\n\n    local function vectorLen(x,y,z)\n        return sqrt(x * x + y * y + z * z)\n    end\n\n    local function local2World(vx,vy,vz)\n        x = vx * cWORx + vy * cWOFx + vz * cWOUx + cWPx\n        y = vx * cWORy + vy * cWOFy + vz * cWOUy + cWPy\n        z = vx * cWORz + vy * cWOFz + vz * cWOUz + cWPz\n        return x,y,z\n    end        \n\n    local function projection2D()\n        vx = posX * camWRx + posY * camWRy + posZ * camWRz\n        vy = posX * camWFx + posY * camWFy + posZ * camWFz\n        vz = posX * camWUx + posY * camWUy + posZ * camWUz\n        sx = (af * vx)/vy\n        sy = ( -tanFov * vz)/vy\n        sz = ( -field * vy + nq)/vy\n        sPX, sPY = (sx+1)*sw*0.5, (sy+1)*sh*0.5 -- screen pos X Y\n        dist = sqrt(posX*posX + posY*posY + posZ*posZ) -- distance from camera to pos\n    end\n\n\n    local SVG = {}\n    local svgi = 0\n\n\n\n    local pCx, pCy, pCz = 0,0,0\n    local size = 5\n    local tempSVG = \"\"\n    local FPx, FPy = 0, 0\n\n    if scaleToggle == true then\n        svgi = svgi + 1\n        SVG[svgi] = [[\n        <style>\n        svg {\n        position:absolute;\n        top:0px;\n        left:0px;\n    }\n        </style>\n        <div>\n        <svg viewBox=\"0 0 ]].. sw ..[[ ]].. sh ..[[\">\n        ]] \n        for ii, layer in ipairs(layeredPolylinePoints) do\n            if (sliceX == true and ii == 1) or (sliceY == true and ii == 2) or (sliceZ == true and ii == 3) then\n                for i, pointCloud in ipairs(layer) do\n                    svgOut = false\n                    tempSVG = [[<polyline class=\"text]]..i..[[\" points=\"]]\n                    for i2, point in ipairs(pointCloud) do\n\n                        pCx, pCy, pCz = local2World(point[1]*scale+adjPosx, point[2]*scale+adjPosy, point[3]*scale+adjPosz+0.5)   \n                        posX = pCx - camWPx\n                        posY = pCy - camWPy\n                        posZ = pCz - camWPz\n                        projection2D()\n                        if i2 == 1 then FPx, FPy = sPX,sPY end\n\n                        if sz < 1 and sPX > 0 and sPX < sw and sPY > 0 and sPY < sh then\n                            --svgi = svgi + 1\n                            --SVG[svgi] = format('<circle cx=\"%.2f\" cy=\"%.2f\" r=\"%.2f\" stroke=\"none\" stroke-width=\"1\" fill=\"%s\" fill-opacity=\"0.85\"/>',\n                            --    sPX,sPY,1/dist*size,color)\n                        end\n                        if sz > 1 or sPX < 0 or sPX > sw or sPY < 0 or sPY > sh then svgOut = true end\n                        tempSVG = tempSVG .. format(\"%0.1f,%0.1f \",sPX,sPY)\n\n                        if i2 == #pointCloud then\n                            tempSVG = tempSVG .. format(\"%0.1f,%0.1f \",FPx, FPy)\n                        end\n\n                    end\n                    tempSVG = tempSVG .. [[\"/>]]\n\n                    stw = format(\"%0.2f\",1 / dist * strokeWidth)\n\n                    if svgOut == false then\n                        svgi = svgi+1\n                        SVG[svgi] = [[\n                        <style>\n                        .text]]..i..[[ {stroke-width:]].. stw ..[[; stroke: ]].. strokeColor..[[; stroke-opacity: ]].. strokeOpacity..[[; fill: ]]..fillColor..[[; fill-opacity: ]]..fillOpacity..[[; stroke-linecap:round; stroke-linejoin:round}\n                        </style>]].. tempSVG\n                    end    \n                end\n            end \n        end\n\n        for i, point in ipairs(elementsDupePos) do\n\n            pCx, pCy, pCz = local2World(point[1]*scale+adjPosx, point[2]*scale+adjPosy, point[3]*scale+adjPosz+0.5)\n            posX = pCx - camWPx\n            posY = pCy - camWPy\n            posZ = pCz - camWPz\n            projection2D()\n\n            local id = elementsIDs[i]\n            local itemId = core.getElementItemIdById(id)\n            local maxHP = core.getElementMaxHitPointsById(id); maxHP = maxHP > 0 and maxHP or 0\n            local HP = core.getElementHitPointsById(id); HP = HP > 0 and HP or 0\n            local color = \"orange\"\n            if HP >= maxHP then color = pointsColor -- max health\n            elseif HP <= 0 then color = \"red\" end -- dead\n\n            if sz < 1 and sPX > 0 and sPX < sw and sPY > 0 and sPY < sh then\n                svgi = svgi + 1\n                SVG[svgi] = format('<circle cx=\"%.2f\" cy=\"%.2f\" r=\"%.2f\" stroke=\"none\" stroke-width=\"1\" fill=\"%s\" fill-opacity=\"0.85\"/>',\n                    sPX,sPY,1/dist*size,color)\n            end   \n        end\n    else   \n\n        --Markers\n        ----------\n        local t = \"\"\n        local style = \"labelWhite\"\n        local fs = 50\n        local n1, n2, n3 = 0, 0, 0\n\n        svgi = svgi +1\n        SVG[svgi] = [[<style>\n        svg {\n    }\n        </style><div>\n        <svg viewBox=\"0 0 ]].. sw ..[[ ]].. sh ..[[\" style=\"\n        position:absolute;\n        top:0px;\n        left:0px;\n        filter: drop-shadow(1px 1px 0px black) drop-shadow(0px 0px 3px black);\n        \">]]\n\n        for i, point in ipairs(elementsPos) do\n            --if debug then DUSystem.print(\"section: 91\") end\n            pCx, pCy, pCz = local2World(point[1], point[2], point[3]) \n            posX = pCx - camWPx\n            posY = pCy - camWPy\n            posZ = pCz - camWPz\n            projection2D()\n            if sz < 1 and sPX > 0 and sPX < sw and sPY > 0  and sPY < sh then\n                --if debug then DUSystem.print(\"section: 92\") end\n\n                -- set local variables --\n                local id = elementsIDs[i]\n                local itemId = core.getElementItemIdById(id)\n                local maxHP = core.getElementMaxHitPointsById(id); maxHP = maxHP > 0 and maxHP or 0\n                local HP = core.getElementHitPointsById(id); HP = HP > 0 and HP or 0\n\n\n                -- lives left --\n                life = \"\"\n                maxLives = core.getElementMaxRestorationsById(id)\n                lives = core.getElementRestorationsById(id)\n                if lives < maxLives then\n                    life = ' ['..lives..'/'..maxLives..']'\n                end\n                coreUnit = itemId == 1417952990 or itemId == 1418170469 or itemId == 183890525 or itemId == 183890713 and 1 or 0\n\n                if HP < maxHP or showFullHp == true or (lives == 0 and coreUnit == 0) then\n                    local item = system.getItem(itemId)\n                    local name = item.locDisplayNameWithSize\n\n                    local color = colorGradient(\"#FF4400\",\"#FFFF44\",HP/maxHP)\n                    if HP >= maxHP then color = \"#FFFFFF\" -- max health\n                    elseif HP <= 0 then color = \"#BB0000\" end -- dead\n\n                    local sF = 0.7 + ((1 / dist) * (4 + utils.clamp(maxHP/1000,0,6)))-- * (fs + maxHP / 1000)) --scaleFactor\n\n                    -- name and pointer\n                    svgi = svgi +1\n                    SVG[svgi] = [[\n                    <circle style=\"opacity:0.8;fill:none;stroke:]]..color..[[;stroke-width:]]..(1*sF)..[[;stroke-miterlimit:]]..(1*sF)..[[;\" cx=\"]]..sPX..[[\" cy=\"]]..sPY..[[\" r=\"]]..(10*sF)..[[\" />\n                    <polyline style=\"opacity:0.8;fill:none;stroke:]]..color..[[;stroke-width:]]..(1*sF)..[[;stroke-miterlimit:]]..(1*sF)..[[;\" points=\"]]..sPX-(10*sF)..[[,]]..sPY-(10*sF)..[[ ]]..sPX-(20*sF)..[[,]]..sPY-(20*sF)..[[ ]]..sPX-(50*sF)..[[,]]..sPY-(20*sF)..[[\"/>\n                    <text text-anchor=\"end\" alignment-baseline=\"bottom\" x=\"]]..sPX-(25*sF)..[[\" y=\"]]..sPY-(22*sF)..[[\" style=\"font-size:]]..11*sF..[[px;fill:]]..color..[[\">]]..name..life..[[</text>\n                    ]]\n\n                    -- health indicator\n                    if HP > 0 then\n                        local E=HP/maxHP*359.99\n                        local F=1\n                        if E<180 then F=0 end\n                        svgi = svgi +1\n                        SVG[svgi] = [[\n                        <path style=\"opacity:0.8;fill:none;stroke:]]..color..[[;stroke-width:]]..(3*sF)..[[;stroke-miterlimit:1;\" d=\"M ]]..sPX+(7*sF)*cos((0-90)*pi/180)..[[ ]]..sPY+(7*sF)*sin((0-90)*pi/180)..[[ A ]]..(7*sF)..[[ ]]..(7*sF)..[[ 0 ]]..F..[[ 1 ]]..sPX+(7*sF)*cos((E-90)*pi/180)..[[ ]]..sPY+(7*sF)*sin((E-90)*pi/180)..[[\"/>\n                        ]]\n                    else\n                        svgi = svgi +1\n                        SVG[svgi] = [[\n                        <polyline style=\"opacity:0.8;fill:none;stroke:]]..color..[[;stroke-width:]]..(3*sF)..[[;stroke-miterlimit:1;\" points=\"]]..sPX-(6*sF)..[[,]]..sPY-(6*sF)..[[ ]]..sPX+(6*sF)..[[,]]..sPY+(6*sF)..[[\"/>\n                        <polyline style=\"opacity:0.8;fill:none;stroke:]]..color..[[;stroke-width:]]..(3*sF)..[[;stroke-miterlimit:1;\" points=\"]]..sPX+(6*sF)..[[,]]..sPY-(6*sF)..[[ ]]..sPX-(6*sF)..[[,]]..sPY+(6*sF)..[[\"/>\n                        ]]\n                    end\n                end\n\n\n            end\n        end\n    end\n\n    svgi = svgi + 1\n    SVG[svgi] = '</svg></div>'\n    local html = concat(SVG)\n    system.setScreen(html)\n    --system.print(\"update\")\nend","filter":{"args":[],"signature":"onUpdate()","slotKey":"-4"},"key":"3"},{"code":"scaleToggle = not scaleToggle","filter":{"args":[{"value":"lalt"}],"signature":"onActionStart(action)","slotKey":"-4"},"key":"4"},{"code":"showFullHp = not showFullHp","filter":{"args":[{"value":"lshift"}],"signature":"onActionStart(action)","slotKey":"-4"},"key":"5"}],"methods":[],"events":[]}
